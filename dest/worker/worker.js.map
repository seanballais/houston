{"version":3,"sources":["../src/worker/worker.ts"],"names":[],"mappings":"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","file":"worker.js","sourcesContent":["/**\n * houston/src/worker/worker.ts\n * The master class for repository processing.\n *\n * @exports {Class} Worker - A processing class\n */\n\nimport * as fs from 'fs-extra'\nimport * as os from 'os'\nimport * as path from 'path'\nimport * as uuid from 'uuid/v4'\n\nimport { Config } from '../lib/config'\nimport { Repository } from '../lib/service/base/repository'\nimport { EventEmitter } from '../lib/utility/eventemitter'\nimport { Log } from './log'\nimport * as type from './type'\n\nconst tempDir = path.resolve(os.tmpdir(), 'houston')\n\nexport class Worker extends EventEmitter implements type.IWorker {\n  /**\n   * config\n   * The configuration to use during processing\n   *\n   * @var {Config}\n   */\n  public config: Config\n\n  /**\n   * repository\n   * A repository to use for this process\n   *\n   * @var {Repository}\n   */\n  public repository: Repository\n\n  /**\n   * context\n   * The data to use for the build\n   *\n   * @var {IContext}\n   */\n  public context: type.IContext\n\n  /**\n   * workspace\n   * The directory that contains the working files\n   *\n   * @var {string}\n   */\n  public workspace: string\n\n  /**\n   * tasks\n   * All of the tasks to run.\n   *\n   * @var {ITaskConstructor[]}\n   */\n  public tasks: type.ITaskConstructor[] = []\n\n  /**\n   * forks\n   * All of the forks we are going to run after the current task ends.\n   *\n   * @var {Worker[]}\n   */\n  public forks: Worker[] = []\n\n  /**\n   * If we are currently running the worker\n   *\n   * @var {Workable}\n   */\n  public running: type.ITask | null\n\n  /**\n   * Creates a new worker process\n   *\n   * @param {Config} config - The configuration to use\n   * @param {Repository} repository - The repository to process on\n   * @param {IContext} context - The starting context for building\n   */\n  constructor (config: Config, repository: Repository, context: type.IContext) {\n    super()\n\n    this.config = config\n    this.repository = repository\n    this.context = context\n\n    this.workspace = path.resolve(tempDir, uuid())\n  }\n\n  /**\n   * fails\n   * Checks if the worker fails\n   *\n   * @return {boolean}\n   */\n  public get fails (): boolean {\n    for (const log of this.context.logs) {\n      if (log.level === Log.Level.ERROR) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * passes\n   * Checks if the worker passes\n   *\n   * @return {boolean}\n   */\n  public get passes (): boolean {\n    return (this.fails === false)\n  }\n\n  /**\n   * runningIndex\n   * Returns the currently running task index\n   *\n   * @return {Number}\n   */\n  protected get runningIndex (): number {\n    if (this.running != null) {\n      return this.tasks.findIndex((task) => {\n        return (this.running instanceof task)\n      })\n    }\n  }\n\n  /**\n   * contexts\n   * Returns a list of all the contexts this worker has, and all of it's forks\n   *\n   * @return {IContext[]}\n   */\n  protected get contexts (): type.IContext[] {\n    return [\n      this.context,\n      ...this.forks\n        .map((worker) => worker.contexts)\n        .reduce((a, b) => [...a, ...b], [])\n    ]\n  }\n\n  /**\n   * result\n   * Returns the result of the worker. Possible, but incomplete if not stopped.\n   *\n   * @return {IResult}\n   */\n  public get result (): type.IResult {\n    const packages = this.contexts\n      .map((ctx) => ({\n        path: ctx.packagePath,\n        type: ctx.packageSystem\n      }))\n      .filter((p) => (p != null))\n\n    // We just assume the longest appcenter and appstream fields are the best\n    const appcenters = this.contexts\n      .map((ctx) => ctx.appcenter)\n      .filter((a) => (a != null))\n      .sort((a, b) => (JSON.stringify(b).length - JSON.stringify(a).length))\n\n    const appstreams = this.contexts\n      .map((ctx) => ctx.appstream)\n      .filter((a) => (a != null))\n      .sort((a, b) => (b.length - a.length))\n\n    const logs = this.contexts\n      .map((ctx) => ctx.logs)\n      .reduce((a, b) => [...a, ...b], [])\n      .filter((l) => (l != null))\n      .reduce((allLogs, log) => {\n        const similarLogIndex = allLogs\n          .findIndex((l) => (l.title === log.title))\n\n        if (similarLogIndex === -1) {\n          return [...allLogs, log]\n        }\n\n        const similarLog = allLogs[similarLogIndex]\n\n        if (similarLog.body.length < log.body.length) {\n          return allLogs.splice(similarLogIndex, 1, log)\n        }\n      }, [])\n\n    return {\n      appcenter: appcenters[0],\n      appstream: appstreams[0],\n      failed: this.fails,\n      logs,\n      packages\n    }\n  }\n\n  /**\n   * setup\n   * Creates a workspace for the process\n   *\n   * @async\n   * @return {void}\n   */\n  public async setup (): Promise<void> {\n    console.log('starting worker with: ', this.context)\n    await this.emitAsync('setup:start')\n\n    await fs.ensureDir(this.workspace)\n\n    await this.emitAsync('setup:end')\n  }\n\n  /**\n   * run\n   * Runs a bun of tasks. The first param is do match the ITask.\n   *\n   * @async\n   */\n  public async run (): Promise<void> {\n    await this.emitAsync('run:start')\n\n    for (const task of this.tasks) {\n      // Run the tasks given to us\n      try {\n        const taskConstructor = await this.emitAsyncChain<type.ITaskConstructor>('task:start', task)\n        this.running = new taskConstructor(this)\n        await this.running.run()\n      } catch (err) {\n        this.report(err)\n      }\n\n      if (this.running == null) {\n        break\n      }\n\n      // And if we have any forks, stop running the tasks, and run the forks\n      if (this.forks.length > 0) {\n        const todoTasks = this.tasks.splice(this.runningIndex)\n        this.forks.forEach((fork) => {\n          fork.tasks = todoTasks\n        })\n\n        await Promise.all(this.forks.map((fork) => fork.run()))\n        break\n      }\n    }\n\n    await this.emitAsync('run:end')\n    this.stop()\n  }\n\n  /**\n   * fork\n   * Creates a new worker, copying most of the properties from this instance.\n   * It will then run all of these forks _AFTER_ the current task is done.\n   *\n   * @example\n   *   Some tests, like setting up the workspace, can have multiple outputs. In\n   *   an effort to keep things linear and _hopefully_ easy to understand the\n   *   order, this is the way we would make multiple outputs possible. If the\n   *   task, it will look at all the repository references and determine what\n   *   kinds of packages it can make. Then, for each distribution, it forks.\n   *   We end up with 3 different `Worker`s running, and on exit, merging\n   *   storages.\n   *\n   * @async\n   * @param {Object} context - Overwrite for the forked context\n   * @return {Worker}\n   */\n  public async fork (context: object): Promise<Worker> {\n    const newContext = Object.assign({}, this.context, context)\n    const fork = this.constructor(this.config, this.repository, newContext)\n\n    this.forks.push(fork)\n\n    return fork\n  }\n\n  /**\n   * teardown\n   * Removes files and cleans up remaining files\n   *\n   * @async\n   * @return {void}\n   */\n  public async teardown (): Promise<void> {\n    await this.emitAsync('teardown:start')\n\n    await fs.remove(this.workspace)\n\n    await this.emitAsync('teardown:end')\n  }\n\n  /**\n   * Adds a log/error to storage\n   *\n   * @param {Error} err\n   * @return {Worker}\n   */\n  public report (err: Error) {\n    // A real error. Not a Log\n    if (!(err instanceof Log)) {\n      this.emit('run:error', err)\n\n      const log = new Log(Log.Level.ERROR, 'Internal error while running')\n        .setError(err)\n\n      this.context.logs.push(log)\n      this.stop()\n    } else {\n      this.context.logs.push(err)\n\n      if (err.level === Log.Level.ERROR) {\n        this.stop()\n      }\n    }\n\n    return this\n  }\n\n  /**\n   * Stops the build if it's currently running\n   *\n   * @return {IResult}\n   */\n  public stop (): type.IResult {\n    this.running = null\n\n    return this.result\n  }\n}\n"]}