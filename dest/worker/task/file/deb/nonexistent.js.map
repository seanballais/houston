{"version":3,"sources":["../src/worker/task/file/deb/nonexistent.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;;;;;;;;AAEH,+BAA8B;AAC9B,6BAA4B;AAE5B,uDAAmD;AACnD,sCAAkC;AAClC,qCAAiC;AAEjC,wBAAgC,SAAQ,WAAI;IAC1C;;;;OAIG;IACH,IAAc,IAAI;QAChB,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,SAAS,CAAC,CAAA;IACvD,CAAC;IAED;;;;OAIG;IACH,IAAc,KAAK;QACjB,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,IAAI,EAAE,0BAA0B,CAAC,CAAA;IAC5D,CAAC;IAED;;;;;OAKG;IACU,GAAG;;YACd,MAAM,KAAK,GAAG,MAAM,WAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAA;YAEpC,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;gBACpB,OAAM;aACP;YAED,MAAM,aAAa,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,IAAI,GAAG,EAAE,EAAE,CAAC,CAAC,CAAA;YAE5E,MAAM,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE,mBAAmB,CAAC,CAAA;YACtD,MAAM,GAAG,GAAG,MAAM,EAAE,CAAC,QAAQ,CAAC,CAAC,EAAE,MAAM,CAAC,CAAA;YAExC,MAAM,SAAG,CAAC,QAAQ,CAAC,SAAG,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,EAAE;gBACrC,KAAK,EAAE,aAAa;gBACpB,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,OAAO;aAC7B,CAAC,CAAA;QACJ,CAAC;KAAA;CACF;AA1CD,gDA0CC","file":"nonexistent.js","sourcesContent":["/**\n * houston/src/worker/task/file/deb/binary.ts\n * Tests debian packages for needed binary file\n */\n\nimport * as fs from 'fs-extra'\nimport * as path from 'path'\n\nimport { glob } from '../../../../lib/utility/glob'\nimport { Log } from '../../../log'\nimport { Task } from '../../task'\n\nexport class FileDebNonexistent extends Task {\n  /**\n   * Folder where non-correctly installed files will end up in the Debian package\n   *\n   * @return {string}\n   */\n  protected get path () {\n    return path.resolve(this.worker.workspace, 'package')\n  }\n\n  /**\n   * Glob for non-correctly installed files\n   *\n   * @return {string}\n   */\n  protected get files () {\n    return path.resolve(this.path, 'package/nonexistent/**/*')\n  }\n\n  /**\n   * Checks no files are incorrectly placed in the deb package\n   *\n   * @async\n   * @return {void}\n   */\n  public async run () {\n    const files = await glob(this.files)\n\n    if (files.length < 1) {\n      return\n    }\n\n    const relativePaths = files.map((file) => file.replace(`${this.path}/`, ''))\n\n    const p = path.resolve(__dirname, 'nonexistentLog.md')\n    const log = await fs.readFile(p, 'utf8')\n\n    throw Log.template(Log.Level.ERROR, p, {\n      files: relativePaths,\n      storage: this.worker.context\n    })\n  }\n}\n"]}