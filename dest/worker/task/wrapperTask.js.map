{"version":3,"sources":["../src/worker/task/wrapperTask.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;;;;;;;;AAEH,gCAA4B;AAE5B,iCAA6B;AAE7B,iBAAyB,SAAQ,WAAI;IAArC;;QAeE;;;;WAIG;QACI,SAAI,GAAU,EAAE,CAAA;IA2DzB,CAAC;IA9EC;;;;OAIG;IACH,IAAW,KAAK;QACd,OAAO,EAAE,CAAA;IACX,CAAC;IAED,yEAAyE;IACzE,IAAW,KAAK,CAAE,KAAyB;QACzC,OAAM;IACR,CAAC;IASD;;;;OAIG;IACH,IAAc,SAAS;QACrB,OAAO,IAAI,CAAC,IAAI;aACb,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC;aACnB,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,KAAK,SAAG,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAA;IAC3C,CAAC;IAED;;;;;OAKG;IACU,GAAG;;YACd,MAAM,IAAI,CAAC,QAAQ,EAAE,CAAA;YAErB,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAA;YAE/C,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC7B,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,CAAA;aACnB;QACH,CAAC;KAAA;IAED;;;;;;OAMG;IACa,QAAQ;;YACtB,KAAK,MAAM,CAAC,IAAI,IAAI,CAAC,KAAK,EAAE;gBAC1B,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;gBAE/B,MAAM,IAAI,CAAC,GAAG,EAAE;qBACb,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAA,CAAC,gBAAgB;aACrD;QACH,CAAC;KAAA;IAED;;;;;;OAMG;IACO,UAAU,CAAE,CAAQ;QAC5B,IAAI,CAAC,YAAY,SAAG,EAAE;YACpB,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAA;SAClB;aAAM;YACL,MAAM,CAAC,CAAA;SACR;IACH,CAAC;CACF;AA/ED,kCA+EC","file":"wrapperTask.js","sourcesContent":["/**\n * houston/src/worker/task/wrapperTask.ts\n * Runs a bunch of tasks in a row, collecting errors for later.\n */\n\nimport { Log } from '../log'\nimport { ITaskConstructor } from '../type'\nimport { Task } from './task'\n\nexport class WrapperTask extends Task {\n  /**\n   * The tasks to run\n   *\n   * @var {ITaskConstructor[]}\n   */\n  public get tasks (): ITaskConstructor[] {\n    return []\n  }\n\n  // BUG: We have to set a no-op setter because Jest will error if we don't\n  public set tasks (tasks: ITaskConstructor[]) {\n    return\n  }\n\n  /**\n   * All of the logs that where gathered\n   *\n   * @var {Log[]}\n   */\n  public logs: Log[] = []\n\n  /**\n   * Returns all of the logs that are errors\n   *\n   * @return {Log[]}\n   */\n  protected get errorLogs () {\n    return this.logs\n      .map((l) => l.level)\n      .filter((l) => (l === Log.Level.ERROR))\n  }\n\n  /**\n   * Does logic.\n   *\n   * @async\n   * @return {void}\n   */\n  public async run () {\n    await this.runTasks()\n\n    this.logs.forEach((l) => this.worker.report(l))\n\n    if (this.errorLogs.length > 0) {\n      this.worker.stop()\n    }\n  }\n\n  /**\n   * Runs all the tasks. This is out of the `run` method to allow easier\n   * custom logic for WrapperTask runners\n   *\n   * @async\n   * @return {void}\n   */\n  protected async runTasks () {\n    for (const T of this.tasks) {\n      const task = new T(this.worker)\n\n      await task.run()\n        .catch((e) => this.catchError(e)) // Binding issue\n    }\n  }\n\n  /**\n   * Catches an error thrown from one of the tasks\n   *\n   * @param {Error} e\n   * @return {void}\n   * @throws {Error}\n   */\n  protected catchError (e: Error): void {\n    if (e instanceof Log) {\n      this.logs.push(e)\n    } else {\n      throw e\n    }\n  }\n}\n"]}